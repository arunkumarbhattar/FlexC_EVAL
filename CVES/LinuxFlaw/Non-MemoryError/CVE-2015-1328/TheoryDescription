# FreeBuf中的简要报道
http://www.freebuf.com/news/70615.html
“当在上层文件系统目录中创建新文件时，overlayfs文件系统未能正确检查此文件的权限。而这一缺陷则可以被内核中没有权限的进程所利用，只要满足该进程CONFIG_USER_NS=y及overlayfs所拥有得FS_USERNS_MOUNT标志，即允许挂载非特权挂载空间的overlayfs。而这一条件是Ubuntu 12.04、14.04、14.10和15.04版本中的默认配置，所以这些版本的Ubuntu系统都受此漏洞影响。
ovl_copy_up_ *函数未能正确检查用户是否有权限向upperdir目录写入文件。而该函数唯一检查的是被修改文件的拥有者是否拥有向upperdir目录写入文件的权限。此外，当从lowerdir目录复制一个文件时，同时也就复制了文件元数据，而并非文件属性，例如文件拥有者被修改为了触发copy_up_*程序的用户。”

# exploit-db
(https://www.exploit-db.com/exploits/37292/)

# LWN 文章
(https://lwn.net/Articles/531114/)

Currently, Linux implements six different types of namespaces. The purpose of each namespace is to wrap a particular global system resource in an abstraction that makes it appear to the processes within the namespace that they have their own isolated instance of the global resource. One of the overall goals of namespaces is to support the implementation of containers, a tool for lightweight virtualization (as well as other purposes) that provides a group of processes with the illusion that they are the only processes on the system. 

User namespaces (CLONE_NEWUSER, started in Linux 2.6.23 and completed in Linux 3.8) isolate the user and group ID number spaces. In other words, a process's user and group IDs can be different inside and outside a user namespace. The most interesting case here is that a process can have a normal unprivileged user ID outside a user namespace while at the same time having a user ID of 0 inside the namespace. This means that the process has full root privileges for operations inside the user namespace, but is unprivileged for operations outside the namespace. 

# USN-2646-2
(http://www.ubuntu.com/usn/usn-2646-2/)

# LD_* 环境变量：
LD_LIBRARY_PATH在搜索库时，此路径的库在标准库之前使用。
LD_PRELOAD列出了所有共享函数库中需要优先加载的库文件，可以覆盖某些函数，功能和/etc/ld.so.preload类似。這個环境变量非常危险，一旦库里面敏感的函数被替换的话，就会出现各种问题，就像本次例子中出现的情况，setuid这个函数被替换了。

如果只是想要覆盖一个库文件的某些函数，但保留其余的内容，可以将覆盖库文件名保存至 /etc/ld.so.preload 文件中。这些覆盖库文件会比标准库文件优先读取，这通常用于紧急的版本补丁。但是现在可以被用于做坏事。

# 攻击思路
我想把我理解下来的思路记录下来：
1. 检测是否可以有漏洞可以被利用。
2. clone函数clone一个线程，然后执行我们指定的一个函数。
3. 在这个函数中，利用overlayfs没有对于upperdir来复制/sys/kernel/security/apparmor文件夹下的.access重命名为ld.so.preload,然后复制到/etc文件夹中，关于ld.so.preload文件的具体内容以及作用，我需要找找对应的资料。
4. 编写一个自己的su程序调用的函数，完成设置uid和gid的功能，然后将其生成动态链接库，同时将其位置放置到ld.so.preload这个文件中。这样就可以覆盖原来的su的程序。

# 评价
能够在没有写权限的情况下，在没有权限的目录下面，写入/生成一个自己没有权限的文件。
