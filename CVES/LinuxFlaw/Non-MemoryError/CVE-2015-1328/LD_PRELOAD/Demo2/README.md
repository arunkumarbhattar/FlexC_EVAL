# Prepare

    $ gcc -shared -o preload.so preload.c
# Result
	$ id
	uid=1000(mdl) gid=1000(mdl) groups=1000(mdl),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(netdev),110(lpadmin),113(scanner),117(bluetooth),127(wireshark)
	$ export LD_PRELOAD="./preload.so"
	User Info
	$ id
	uid=1000(mdl) gid=1000(mdl) euid=0(root) egid=0(root) groups=0(root),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(netdev),110(lpadmin),113(scanner),117(bluetooth),127(wireshark),1000(mdl)
	User Info
	$ whoami
	root

	$ /bin/sh
	#         <------ 你可以看到命令行提示符会由 $ 变成 #
	But when I want to create regular file in /etc, there are errors.
	# cd /etc
	# touch test
	ERROR: ld.so: object './preload.so' from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored.
    touch: cannot touch ‘test’: Permission denied
# Evaluation
preload.c文件也就早期的为人所熟知的hack程序了。恶意用户通过在系统中设计LC_PRELOAD环境变量来加载这个动态链接库，会非常容易影响其它系统命令（如：```/bin/sh, /bin/ls, /bin/rm``` 等），让这些系统命令以Root权限运行。

# Proof
    printf (_("uid=%s"), uidtostr (ruid));
    pwd = getpwuid (ruid);
    if (pwd)
        printf ("(%s)", pwd->pw_name);
 
    printf (_(" gid=%s"), gidtostr (rgid));
    grp = getgrgid (rgid);
    if (grp)
    printf ("(%s)", grp->gr_name);
 
    if (euid != ruid)
	{
	    printf (_(" euid=%s"), uidtostr (euid));
        pwd = getpwuid (euid);
        if (pwd)
            printf ("(%s)", pwd->pw_name);
	}

    if (egid != rgid)
	{
	    printf (_(" egid=%s"), gidtostr (egid));
	    grp = getgrgid (egid);
	    if (grp)
	    printf ("(%s)", grp->gr_name);
	}

