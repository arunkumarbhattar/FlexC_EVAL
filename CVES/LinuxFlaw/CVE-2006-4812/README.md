# CVE-2006-4812

## Experiment Environment

CentOS 6.5

## INSTALL & Configuration

```
https://github.com/mudongliang/source-packages/raw/master/CVE-2006-4812/php-5.1.6.tar.gz
tar -xvf php-5.1.6.tar.gz
cd php-5.1.6
./configure
make
```

## Problems in Installation & Configuration

## How to trigger vulnerability

```
./sapi/cli/php exploit.php
```

## PoCs

[PHP ZendEngine ECalloc Integer Overflow Vulnerability](https://www.securityfocus.com/bid/20349/exploit)

[PHP 3 < 5 - ZendEngine ECalloc Integer Overflow](https://www.exploit-db.com/exploits/28760/)

## Vulnerability Details & Patch

### Root Cause

>   unserialize() is a PHP function that allows deserialisation of
>   previously serialised PHP variables. Many applications use it
>   to store PHP variables in an easy accessible data format. Some
>   of them even put serialised strings into COOKIEs and later
>   unserialize() them again.
   
>   Unfortunately passing user-input to unserialize() is a bad idea
>   because it also supports the deserialisation of objects, which
>   might influence the application. Additionally it is trivial to
>   crash PHP with a large amount of nested arrays.

### Stack Trace

### Patch

```
 ZEND_API void *_ecalloc(size_t nmemb, size_t size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)
 {
 	void *p;
-	int final_size = size*nmemb;
-	
+
 	HANDLE_BLOCK_INTERRUPTIONS();
-	p = _emalloc(final_size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);
+	p = _safe_emalloc(nmemb, size, 0 ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);
 	if (!p) {
 		HANDLE_UNBLOCK_INTERRUPTIONS();
 		return (void *) p;
 	}
-	memset(p, 0, final_size);
+	memset(p, 0, size * nmemb);
 	HANDLE_UNBLOCK_INTERRUPTIONS();
 	return p;
 }
```

## References

[Advisory 09/2006: PHP unserialize() Array Creation Integer Overflow](http://www.hardened-php.net/advisory_092006.133.html)
