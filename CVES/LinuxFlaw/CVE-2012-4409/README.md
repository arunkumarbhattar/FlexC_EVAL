# CVE-2012-4409

## Experiment Environment

Ubuntu 14.04 LTS

## INSTALL & Configuration

```
wget https://github.com/mudongliang/source-packages/raw/master/CVE-2012-4409/mcrypt-2.5.8.tar.gz

tar -xvf mcrypt-2.5.8.tar.gz
cd mcrypt-2.5.8

./configure
make
```

## Problems in Installation & Configuration

Install ```mhash``` fro  http://mhash.sourceforge.net

```
/usr/bin/ld: i386 architecture of input file `errors.o' is incompatible with i386:x86-64 output
/usr/bin/ld: i386 architecture of input file `gaaout.o' is incompatible with i386:x86-64 output
```

In file `errors.c`, `#include <stdlib.h>` should be added for it has used function `exit()`; In file `gaaout.c`, macro `GAAERROR` is defined as a void return which is used in some non-void return functions. They have caused the binary issues.

In 64bits architecture (e.g. x86-64 or aarch64), the source code may be compiled smoothly, but the output program might cause segmentation fault when running without any command line parameters (Similar situation is decribed in [NOTE.md](NOTE.md), but the root reason is not pointed out). The root reason is that the signature of `_mcrypt_malloc()` is missing as the `xmalloc.h` who has the signature is not included in `xmalloc.c` and `gaaout.c`. Then the return type of `_mcrypt_malloc()` would be regarded as a default type `int`, which has a length of 32bits. Then the compiler would generate a signed extend instruction (e.g. sxtw in aarch64 and cltq in x86-64) after return from this function. It is going to cause the pointer value being corrupted and then a segmentation fault.

Patch [fix-some-compile-issues.patch](fix-some-compile-issues.patch) is prepared to fix these issues above.

Before running `./configure`, use
```
patch -p1 < ../fix-some-compile-issues.patch
```
to patch the source, and then configure and make.

## How to trigger vulnerability

```
perl mcrypt.pl
./mcrypt -d fake.nc
```

## PoCs

[mcrypt 2.5.8 - Stack Based Overflow](https://www.exploit-db.com/exploits/22928/)

## Vulnerability Details & Patch

### Root Cause

```
extra.c:239

			fread(tmp_buf, 1, *salt_size,
                                              fstream);
```

### Stack Trace

```
(gdb) info stack
#0  0x0804a147 in check_file_head (fstream=0x5a5ed08, 
    algorithm=0x5a5ed08 <error: Cannot access memory at address 0x5a5ed08>, 
    mode=0x5a5ed08 <error: Cannot access memory at address 0x5a5ed08>, 
    keymode=0x55a6308 <error: Cannot access memory at address 0x55a6308>, keysize=0x5b00008, salt=0x4800708, 
    salt_size=0x499f008) at extra.c:241
#1  0x05a5ed08 in ?? ()
#2  0x05a5ed08 in ?? ()
#3  0x05a5ed08 in ?? ()
```

### Patch

```
diff -urpN mcrypt-2.6.8-1.orig/src/errors.c mcrypt-2.6.8-1/src/errors.c
--- mcrypt-2.6.8-1.orig/src/errors.c	2007-11-07 11:10:19.000000000 -0600
+++ mcrypt-2.6.8-1/src/errors.c	2012-09-06 14:51:57.614219938 -0500
@@ -24,24 +24,24 @@ extern int quiet;
 
 void err_quit(char *errmsg)
 {
-	fprintf(stderr, errmsg);
+	fprintf(stderr, "%s", errmsg);
 	exit(-1);
 }
 
 void err_warn(char *errmsg)
 {
 	if (quiet <= 1)
-		fprintf(stderr, errmsg);
+		fprintf(stderr, "%s", errmsg);
 }
 
 void err_info(char *errmsg)
 {
 	if (quiet == 0)
-		fprintf(stderr, errmsg);
+		fprintf(stderr, "%s", errmsg);
 }
 
 void err_crit(char *errmsg)
 {
 	if (quiet <= 2)
-		fprintf(stderr, errmsg);
+		fprintf(stderr, "%s", errmsg);
 }

diff -urpN mcrypt-2.6.8-1.orig/src/extra.c mcrypt-2.6.8-1/src/extra.c
--- mcrypt-2.6.8-1.orig/src/extra.c	2007-11-07 11:10:20.000000000 -0600
+++ mcrypt-2.6.8-1/src/extra.c	2012-09-06 14:45:34.337011563 -0500
@@ -242,6 +242,8 @@ int check_file_head(FILE * fstream, char
 			if (m_getbit(0, sflag) != 0) { /* if the first bit is set */
 				*salt_size = m_setbit(0, sflag, 0);
 				if (*salt_size > 0) {
+					if (*salt_size > sizeof(tmp_buf))
+					    err_quit(_("Salt is too long\n"));
 					fread(tmp_buf, 1, *salt_size,
 					      fstream);
 					memmove(salt, tmp_buf, *salt_size);
```

## References

[1] [mcrypt buffer overflow flaw](http://www.openwall.com/lists/oss-security/2012/09/06/8)
