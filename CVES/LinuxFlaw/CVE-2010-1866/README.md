# CVE/EDB ID

## Experiment Environment

CentOS 6.5

## INSTALL & Configuration

```
wget https://github.com/mudongliang/source-packages/raw/master/CVE-2010-1866/php-5.3.2.tar.gz
tar -xvf php-5.3.2.tar.gz
cd php-5.3.2
./configure
make
```

## Problems in Installation & Configuration


## How to trigger vulnerability

```
./sapi/cli/php poc.php
```

## PoCs

[PHP 5.3 - 'PHP_dechunk()' HTTP Chunked Encoding Integer Overflow](https://www.exploit-db.com/exploits/33920/)

[PHP 'php_dechunk()' HTTP Chunked Encoding Integer Overflow Vulnerability](https://www.securityfocus.com/bid/39877/exploit)

## Vulnerability Details & Patch

### Root Cause

The new PHP dechunk filter consists of a state machine that uses the following structure to remember the current state.

```
typedef struct _php_chunked_filter_data {
    php_chunked_filter_state state;
    int chunk_size;
    int persistent;
} php_chunked_filter_data;
```

The chunk_size is stored in a signed integer which can result in problems because of the chunk size decoder used.

```
case CHUNK_SIZE:
    while (p < end) {
        if (*p >= '0' && *p <= '9') {
            data->chunk_size = (data->chunk_size * 16) + (*p - '0');
        } else if (*p >= 'A' && *p <= 'F') {
            data->chunk_size = (data->chunk_size * 16) + (*p - 'A' + 10);
        } else if (*p >= 'a' && *p <= 'f') {
            data->chunk_size = (data->chunk_size * 16) + (*p - 'a' + 10);
        } else if (data->state == CHUNK_SIZE_START) {
            data->state = CHUNK_ERROR;
            break;
        } else {
            data->state = CHUNK_SIZE_EXT_START;
            break;
        }
        data->state = CHUNK_SIZE;
        p++;
    }
```

The chunk size decoder does not protect itself against integer overflows and therefore a positive 32 bit chunk size will result in a negative integer being stored in the chunk_size state variable. This causes problems in a later state that compares the chunk size against the remaining buffer space.

```
case CHUNK_BODY:
    if (end - p >= data->chunk_size) {
        if (p != out) {
            memmove(out, p, data->chunk_size);
        }
        out += data->chunk_size;
        out_len += data->chunk_size;
        p += data->chunk_size;
```

It should be obvious that a negative chunk size being stored in the chunk_size signed integer variable will pass the check and result in 2GB to 4GB being copied between the two heap buffers. Usually this will result in a crash only but in a multithreaded webserver this could result in a more serious exploitable memory corruption. Luckily PHP is rarely used in a multithreaded environment.



### Stack Trace

### Patch

<http://svn.php.net/viewvc/php/php-src/branches/PHP_5_3/ext/standard/filters.c?r1=298700&r2=298699&pathrev=298700>

## References
