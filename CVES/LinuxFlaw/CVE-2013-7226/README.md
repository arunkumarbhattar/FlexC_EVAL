# CVE-2013-7226

## Experiment Environment

Ubuntu 14.04LTS

## INSTALL & Configuration

```
wget https://github.com/mudongliang/source-packages/raw/master/CVE-2013-7226/php-5.5.0.tar.gz
tar -xvf php-5.5.0.tar.gz
cd php-5.5.0
./configure --with-gd
make
```

## Problems in Installation & Configuration


## How to trigger vulnerability

```
./sapi/cli/php poc1.php

./sapi/cli/php poc2.php

./sapi/cli/php poc3.php

./sapi/cli/php poc4.php
```

## PoCs

[Heap Overflow Vulnerability in imagecrop()](https://bugs.php.net/bug.php?id=66356)

## Vulnerability Details & Patch

### Root Cause

The imagecrop() function can be used to crop an image with the following call:

	$dimensions = array("x" => 10, "y" => 10, "width" => 50, "height" => 50);
	$new_image = image($image, $dimensions);

The implementation of imagecrop() in ext/gd/gd.c performs very little checking of the supplied dimensions:

	gdRect rect;
	...
	if (zend_hash_find(HASH_OF(z_rect), "x", sizeof("x"), (void **)&tmp) != FAILURE) {
		rect.x = Z_LVAL_PP(tmp);
	} else {
	...

One issue here is that there is no check of tmp's type nor a conversion. This means that if the dimensions array contains the key "x", its zval's value will be treated as an integer even if it's really a string or an array. This can be used as an information leak vulnerability, because strings and array contain pointers which can be used for subsequent exploits.

### Stack Trace

### Patch

```
diff --git a/ext/gd/libgd/gd_crop.c b/ext/gd/libgd/gd_crop.c
index f0b888a..90a99a6 100644 (file)
--- a/ext/gd/libgd/gd_crop.c
+++ b/ext/gd/libgd/gd_crop.c
@@ -44,6 +44,12 @@ gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)
 {
        gdImagePtr dst;
 
+       /* check size */
+       if (crop->width<=0 || crop->height<=0) {
+               return NULL;
+       }
+
+       /* allocate the requested size (could be only partially filled) */
        if (src->trueColor) {
                dst = gdImageCreateTrueColor(crop->width, crop->height);
                gdImageSaveAlpha(dst, 1);
@@ -51,37 +57,43 @@ gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)
                dst = gdImageCreate(crop->width, crop->height);
                gdImagePaletteCopy(dst, src);
        }
+       if (dst == NULL) {
+               return NULL;
+       }
        dst->transparent = src->transparent;
 
-       if (src->sx < (crop->x + crop->width -1)) {
-               crop->width = src->sx - crop->x + 1;
+       /* check position in the src image */
+       if (crop->x < 0 || crop->x>=src->sx || crop->y<0 || crop->y>=src->sy) {
+               return dst;
+       }
+
+       /* reduce size if needed */
+       if ((src->sx - crop->width) < crop->x) {
+               crop->width = src->sx - crop->x;
        }
-       if (src->sy < (crop->y + crop->height -1)) {
-               crop->height = src->sy - crop->y + 1;
+       if ((src->sy - crop->height) < crop->y) {
+               crop->height = src->sy - crop->y;
        }
+
 #if 0
 printf("rect->x: %i\nrect->y: %i\nrect->width: %i\nrect->height: %i\n", crop->x, crop->y, crop->width, crop->height);
 #endif
-       if (dst == NULL) {
-               return NULL;
+       int y = crop->y;
+       if (src->trueColor) {
+               unsigned int dst_y = 0;
+               while (y < (crop->y + (crop->height - 1))) {
+                       /* TODO: replace 4 w/byte per channel||pitch once available */
+                       memcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);
+               }
        } else {
-               int y = crop->y;
-               if (src->trueColor) {
-                       unsigned int dst_y = 0;
-                       while (y < (crop->y + (crop->height - 1))) {
-                               /* TODO: replace 4 w/byte per channel||pitch once available */
-                               memcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);
-                       }
-               } else {
-                       int x;
-                       for (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {
-                               for (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {
-                                       dst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];
-                               }
+               int x;
+               for (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {
+                       for (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {
+                               dst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];
                        }
                }
-               return dst;
        }
+       return dst;
 }
```

Details are in <http://git.php.net/?p=php-src.git;a=commitdiff;h=8f4a5373bb71590352fd934028d6dde5bc18530b>

## References
