--- Python-2.4.3/Modules/rgbimgmodule.c.orig	2002-08-02 04:27:13.000000000 +0200
+++ Python-2.4.3/Modules/rgbimgmodule.c	2010-05-04 21:02:11.000000000 +0200
@@ -20,13 +20,8 @@
 typedef int Py_Int32;
 typedef unsigned int Py_UInt32;
 #else
-#if SIZEOF_LONG == 4
-typedef long Py_Int32;
-typedef unsigned long Py_UInt32;
-#else
 #error "No 4-byte integral type"
 #endif
-#endif
 
 #include <string.h>
 
@@ -92,7 +87,7 @@ typedef struct {
 
 #define CHANOFFSET(z)	(3-(z))	/* this is byte order dependent */
 
-static void expandrow(unsigned char *, unsigned char *, int);
+static int expandrow(unsigned char *, unsigned char *, int, int);
 static void setalpha(unsigned char *, int);
 static void copybw(Py_Int32 *, int);
 static void interleaverow(unsigned char*, unsigned char*, int, int);
@@ -299,7 +294,11 @@ longimagedata(PyObject *self, PyObject *
 	xsize = image.xsize;
 	ysize = image.ysize;
 	zsize = image.zsize;
+	if (image.zsize > 4)
+		goto corrupted;
+
 	if (rle) {
+		/* these can't oveflow, as xsize and ysize <= 0xffff and zsize <= 4 */
 		tablen = ysize * zsize * sizeof(Py_Int32);
 		starttab = (Py_Int32 *)malloc(tablen);
 		lengthtab = (Py_Int32 *)malloc(tablen);
@@ -331,6 +330,10 @@ longimagedata(PyObject *self, PyObject *
 
 		fseek(inf, 512 + 2 * tablen, SEEK_SET);
 		cur = 512 + 2 * tablen;
+		if (ysize > 0 && xsize > (INT_MAX/sizeof(Py_Int32)-TAGLEN)/ysize) {
+			PyErr_NoMemory();
+			goto finally;
+		}
 		rv = PyString_FromStringAndSize((char *)NULL,
 				      (xsize * ysize + TAGLEN) * sizeof(Py_Int32));
 		if (rv == NULL)
@@ -354,15 +357,13 @@ longimagedata(PyObject *self, PyObject *
 						cur = starttab[idx];
 					}
 					if (lengthtab[idx] > rlebuflen) {
-						PyErr_SetString(ImgfileError,
-							"rlebuf is too small");
-						Py_DECREF(rv);
-						rv = NULL;
-						goto finally;
+						PyErr_SetString(ImgfileError, "rlebuf is too small");
+						goto corrupted;
 					}
 					fread(rledat, lengthtab[idx], 1, inf);
 					cur += lengthtab[idx];
-					expandrow(lptr, rledat, 3-z);
+					if (expandrow(lptr, rledat, 3-z, xsize) != 0)
+						goto corrupted;
 					if (reverse_order)
 						lptr -= xsize
 						      * sizeof(Py_UInt32);
@@ -384,9 +385,14 @@ longimagedata(PyObject *self, PyObject *
 						      SEEK_SET);
 						cur = starttab[idx];
 					}
+					if (lengthtab[idx] > rlebuflen) {
+						PyErr_SetString(ImgfileError, "rlebuf is too small");
+						goto corrupted;
+					}
 					fread(rledat, lengthtab[idx], 1, inf);
 					cur += lengthtab[idx];
-					expandrow(lptr, rledat, 3-z);
+					if (expandrow(lptr, rledat, 3-z, xsize) != 0)
+						goto corrupted;
 				}
 				if (reverse_order)
 					lptr -= xsize * sizeof(Py_UInt32);
@@ -400,6 +406,10 @@ longimagedata(PyObject *self, PyObject *
 			copybw((Py_Int32 *) base, xsize * ysize);
 	}
 	else {
+		if (ysize > 0 && xsize > (INT_MAX/sizeof(Py_Int32)-TAGLEN)/ysize) {
+			PyErr_NoMemory();
+			goto finally;
+		}
 		rv = PyString_FromStringAndSize((char *) 0,
 					   (xsize*ysize+TAGLEN)*sizeof(Py_Int32));
 		if (rv == NULL)
@@ -430,6 +440,14 @@ longimagedata(PyObject *self, PyObject *
 		else if (zsize < 3) 
 			copybw((Py_Int32 *) base, xsize * ysize);
 	}
+	goto finally;
+  corrupted:
+	PyErr_SetString(ImgfileError,
+			"input image file is corrupted");
+	if (rv) {
+		Py_DECREF(rv);
+		rv = NULL;
+	}
   finally:
 	free(starttab);
 	free(lengthtab);
@@ -493,8 +511,8 @@ setalpha(unsigned char *lptr, int n)
 	}
 }
 
-static void
-expandrow(unsigned char *optr, unsigned char *iptr, int z)
+static int
+expandrow(unsigned char *optr, unsigned char *iptr, int z, int n)
 {
 	unsigned char pixel, count;
 
@@ -502,7 +520,12 @@ expandrow(unsigned char *optr, unsigned 
 	while (1) {
 		pixel = *iptr++;
 		if (!(count = (pixel & 0x7f)))
-			return;
+			return 0;
+		/* don't write more than n byte to output */
+		if (count > n)
+			return 1;
+		else
+			n -= count;
 		if (pixel & 0x80) {
 			while (count >= 8) {
 				optr[0 * 4] = iptr[0];
@@ -573,6 +596,14 @@ longstoimage(PyObject *self, PyObject *a
 	if (!PyArg_ParseTuple(args, "s#iiis:longstoimage", &lptr, &len,
 			      &xsize, &ysize, &zsize, &name))
 		return NULL;
+	
+	if (xsize < 0 || xsize > 0xffff
+			||  ysize < 0 || ysize > 0xffff
+			||  zsize < 0 || zsize > 4) {
+		PyErr_SetString(ImgfileError, "invalid xsize, ysize, or zsize");
+		return NULL;
+	}
+
 
 	goodwrite = 1;
 	outf = fopen(name, "wb");
@@ -580,8 +611,9 @@ longstoimage(PyObject *self, PyObject *a
 		PyErr_SetString(ImgfileError, "can't open output file");
 		return NULL;
 	}
-	tablen = ysize * zsize * sizeof(Py_Int32);
 
+	/* these can't oveflow, as xsize and ysize <= 0xffff and zsize <= 4 */
+	tablen = ysize * zsize * sizeof(Py_Int32);
 	starttab = (Py_Int32 *)malloc(tablen);
 	lengthtab = (Py_Int32 *)malloc(tablen);
 	rlebuflen = (int) (1.05 * xsize + 10);
