下面是所有的samba的命令：

    ?              allinfo        altname        archive        blocksize      
    cancel         case_sensitive cd             chmod          chown          
    close          del            dir            du             echo           
    exit           get            getfacl        hardlink       help           
    history        iosize         lcd            link           lock           
    lowercase      ls             l              mask           md             
    mget           mkdir          more           mput           newer          
    open           posix          posix_encrypt  posix_open     posix_mkdir    
    posix_rmdir    posix_unlink   print          prompt         put            
    pwd            q              queue          quit           rd             
    recurse        reget          rename         reput          rm             
    rmdir          showacls       setmode        stat           symlink        
    tar            tarmode        translate      unlock         volume         
    vuid           wdel           logon          listconnect    showconnect    
    ..             !       

从漏洞代码分析报告可得到，所有的samba命令执行在找到对应的cmd_XXX function pointer 之前都是一致的，我们首先从main函数进行分析:

main -> process_command_string -> 通过commands数组name变量的比对(`process_tok(tok)`)，找到正确的命令对应的函数 -> 执行对应的函数即可

    static int process_command_string(const char *cmd_in)
    {
        TALLOC_CTX *ctx = talloc_tos();
        char *cmd = talloc_strdup(ctx, cmd_in); //拷贝cmd字符串
	    int rc = 0;

        if (!cmd) {
            return 1;
        }
        // 将cmd字符穿以；拆开，分条进行执行；
        while (cmd[0] != '\0')    {
            char *line;
            char *p;
            char *tok;
            int i;
            // 查找分号的存在，由于我测试使用的命令都是没有 ';' 的，所以直接按照为 true 执行。
		    if ((p = strchr_m(cmd, ';')) == 0) {
                line = cmd;
                cmd += strlen(cmd);
            } else {
                *p = '\0';
                line = cmd;
                cmd = p + 1;
            }
           /*and get the first part of the command 用我的话，由于我输入的命令都是没有 ';' 的单条命令，
            *cmd_ptr，line，cmd是一致的，由于有些命令会有参数，比如说 put，get 命令的文件名，所以tok只是
            *cmd_ptr的参数部分，而且next_token_talloc 可以不断的获取命令参数，可以类比于argv[1..] */
            cmd_ptr = line;
            if (!next_token_talloc(ctx, &cmd_ptr,&tok,NULL)) {
                continue;
            }
            // process_tok 的主要工作就是检查tok和哪个命令相同，然后执行对应命令的function pointer
            if ((i = process_tok(tok)) >= 0) {
                rc = commands[i].fn();
            } else if (i == -2) {
                d_printf("%s: command abbreviation ambiguous\n",tok);
            } else {
                d_printf("%s: command not found\n",tok);
            }
       }

	   return rc;
    }

关于**有漏洞的命令**（没有漏洞的命令就没有看，不过类同）具体有什么样的系统调用，如下所示，

- do_cd：同 cd 命令，本地会调用`cli_chkpath`来通知远端切换目录。
- cmd_dir：同 ls 命令，本地会调用`cli_list`来通知远端查看文件/文件夹信息。
- cmd_du：同 du 命令，本地会调用`cli_dskattr`来通知远端查看文件/文件夹大小。
- cmd_get：从samba上拷贝文件到本地，本地会调用`cli_open`,`cli_close`,**sys_lseek**,**sys_open**
- cmd_more：同 more 命令，和cmd_get相同，调用的也是 do_get ，本地会调用`cli_open`,`cli_close`,**sys_lseek**,**sys_open**
- cmd_mget：同 get 命令，只不过可以同时get多个文件
- cmd_mkdir：同 mkdir 命令，本地会调用`cli_mkdir`来通知远端创建文件夹
- cmd_altname：显示文件的 alt name ，本地`cli_qpathinfo_alt_name`来获取文件的 alt name
- cmd_allinfo：列举所有可用的信息，本地会调用`cli_qpathinfo2来获取文件信息
- cmd_put：从本地向远端拷贝文件，本地会调用`cli_open`,`cli_qfileinfo`,`cli_write`,`cli_close`,**sys_open**,**sys_lseek**,**sys_stat**,**close**
- cmd_del：同 rm 命令，本地会调用`cli_unlink`删除对应文件
- cmd_reput：将本地文件放置到远程文件后面，若没有远程文件名，其效果同 cmd_put

我们以sys_open来说其内部调用open的过程：

    /*******************************************************************
     An open() wrapper that will deal with 64 bit filesizes.
     ********************************************************************/

    int sys_open(const char *path, int oflag, mode_t mode)
    {
    #if defined(HAVE_EXPLICIT_LARGEFILE_SUPPORT) && defined(HAVE_OPEN64)
        return open64(path, oflag, mode);
    #else
        return open(path, oflag, mode);
    #endif
    }

现在发现了一个重要问题，本身就是smbclient，里面没有什么对本地操作的库函数或者 system calls（除了 mget/get/put ），其他都是直接在remote执行对应的库函数或者 system calls 。而所有的对远程的操作（**以cli开头的函数**）都是通过 socket 来完成的。
那么现在就涉及到一个问题，我们可以通过这个漏洞改什么东西？

