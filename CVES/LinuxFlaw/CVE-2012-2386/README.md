# CVE-2012-2386

## Experiment Environment

CentOS 6.5

## INSTALL & Configuration

```
wget https://github.com/mudongliang/source-packages/raw/master/CVE-2012-2386/php-5.3.6.tar.bz2
tar -xvf php-5.3.6.tar.bz2
cd php-5.3.6
./configure
make
sudo make install
```

## Problems in Installation & Configuration


## How to trigger vulnerability

```
./sapi/cli/php poc.php
```

## PoCs

[PHP 'phar' Extension 1.1.1 - Heap Overflow](https://www.exploit-db.com/exploits/17201/)

[PHP 'phar/tar.c' Heap Buffer Overflow Vulnerability](https://www.securityfocus.com/bid/47545/exploit) miss the poc.phar.tar, you could find it from previous PoC link

## Vulnerability Patch

### Root Cause

An integer overflow vulnerability leading to a heap overflow in the file php-5.3.6/ext/phar/tar.c.

```
195 int phar_parse_tarfile(php_stream* fp, char *fname, int fname_len, char *alias, int alias_len, phar     _archive_data** pphar, int is_data, php_uint32 compression, char **error TSRMLS_DC) /* {{{ */
196 {
	......
255         size = entry.uncompressed_filesize = entry.compressed_filesize =
256             phar_tar_number(hdr->size, sizeof(hdr->size));
        ......
339             entry.filename_len = entry.uncompressed_filesize;
340             entry.filename = pemalloc(entry.filename_len+1, myphar->is_persistent);
341 
342             read = php_stream_read(fp, entry.filename, entry.filename_len);
	......
```

If entry.filename_len(which attacker can control) equal 0xffffffff, pemalloc() will allocate zero length buffer. Then php_stream_read() get as a length parameter 0xffffffff value. Because php_stream_read () checks that the passed length does not exceed the amount of data available, the buffer overflow sizes are available from the data stream.

### Stack Trace

### Patch

```
diff --git a/ext/phar/tar.c b/ext/phar/tar.c
index 9d1e5bc..b914db1 100644
--- a/ext/phar/tar.c
+++ b/ext/phar/tar.c
@@ -337,6 +337,16 @@ bail:
 			last_was_longlink = 1;
 			/* support the ././@LongLink system for storing long filenames */
 			entry.filename_len = entry.uncompressed_filesize;
+
+			/* Check for overflow - bug 61065 */
+			if (entry.filename_len == UINT_MAX) {
+				if (error) {
+					spprintf(error, 4096, "phar error: \"%s\" is a corrupted tar file (invalid entry size)", fname);
+				}
+				php_stream_close(fp);
+				phar_destroy_phar_data(myphar TSRMLS_CC);
+				return FAILURE;
+			}
 			entry.filename = pemalloc(entry.filename_len+1, myphar->is_persistent);
 
 			read = php_stream_read(fp, entry.filename, entry.filename_len);
```

## References
