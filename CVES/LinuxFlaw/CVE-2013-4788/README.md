# CVE-2013-4788

## Experiment Environment

CentOS 6.5

## INSTALL & Configuration

Preinstalled environment

## Problems in Installation & Configuration


## How to trigger vulnerability

```
gcc -o POC poc.c -static
./POC
```

## PoCs

[glibc and eglibc 2.5/2.7/2.13 - Local Buffer Overflow](https://www.exploit-db.com/exploits/28657/)

[CVE-2013-4788 - Eglibc PTR MANGLE vulnerability](http://hmarco.org/bugs/CVE-2013-4788.html)

[CVE-2013-4788 - Eglibc PTR MANGLE bug](http://www.openwall.com/lists/oss-security/2013/07/15/9)

## Vulnerability Details & Patch

### Root Cause

Library functions like "setjmp()" or "longjmp()" use PTR_MANGLE and PTR_DEMANGLE. These macros are used to protect structures like jmp_buf. Basically consist on XOR-ing the pointer value with a random 32/64-bit value. Since the pointer guard (random value) is 0x0 the attacker can easily calculate off-line the value of a target address. By overwriting the "env" structure with the pre-computed address the vulnerability is triggered when longjmp() is called and the execution flow is redirected to attacker address. 

### Stack Trace

### Patch

```
diff -rupN glibc-2.17/csu/libc-start.c glibc-2.17-mangle-fix/csu/libc-start.c
--- glibc-2.17/csu/libc-start.c 2012-12-25 04:02:13.000000000 +0100
+++ glibc-2.17-mangle-fix/csu/libc-start.c      2013-07-10 00:13:48.000000000 +0200
@@ -38,6 +38,12 @@ extern void __pthread_initialize_minimal
    in thread local area.  */
 uintptr_t __stack_chk_guard attribute_relro;
 # endif
+
+# ifndef  THREAD_SET_POINTER_GUARD
+uintptr_t __pointer_chk_guard_local
+     attribute_relro attribute_hidden __attribute__ ((nocommon));
+# endif
+
 #endif
 
 #ifdef HAVE_PTR_NTHREADS
@@ -184,6 +190,14 @@ LIBC_START_MAIN (int (*main) (int, char
 # else
   __stack_chk_guard = stack_chk_guard;
 # endif
+    uintptr_t pointer_chk_guard = _dl_setup_pointer_guard (_dl_random,
+                          stack_chk_guard);
+# ifdef THREAD_SET_POINTER_GUARD
+      THREAD_SET_POINTER_GUARD (pointer_chk_guard);
+# else
+      __pointer_chk_guard_local = pointer_chk_guard;
+# endif
+
 #endif
 
   /* Register the destructor of the dynamic linker if there is any.  */
```

## References
